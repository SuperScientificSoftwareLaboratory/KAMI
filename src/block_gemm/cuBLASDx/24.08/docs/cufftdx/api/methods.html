<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Execution Methods &mdash; cuFFTDx 1.2.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/cufftdx_override.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Examples" href="../examples.html" />
    <link rel="prev" title="Traits" href="traits.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" > 

          
          
          <a href="../index.html" class="icon icon-home">
            cuFFTDx
          </a>
              <div class="version">
                1.2.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #76b900;
    }

    .wy-side-nav-search a:link, .wy-nav-top a:link {
      color: #fff;
    }
    .wy-side-nav-search a:visited, .wy-nav-top a:visited {
      color: #fff;
    }
    .wy-side-nav-search a:hover, .wy-nav-top a:hover {
      color: #fff;
    }

    .wy-menu-vertical a:link, .wy-menu-vertical a:visited {
      color: #d9d9d9
    }

    .wy-menu-vertical a:active {
      background-color: #76b900
    }

    .wy-side-nav-search>div.version {
      color: rgba(0, 0, 0, 0.3)
    }

    /* override table width restrictions */
    .wy-table-responsive table td, .wy-table-responsive table th {
        white-space: normal;
    }

    .wy-table-responsive {
        margin-bottom: 24px;
        max-width: 100%;
        overflow: visible;
    }
  </style>
  
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Documentation home</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User guide:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../requirements_func.html">Requirements and Functionality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../requirements_func.html#requirements">Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../requirements_func.html#supported-compilers">Supported Compilers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../requirements_func.html#supported-functionality">Supported Functionality</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Quick Installation Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#cufftdx-in-your-project">cuFFTDx In Your Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#cufftdx-in-your-cmake-project">cuFFTDx In Your CMake Project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../installation.html#defined-variables">Defined Variables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../introduction1.html">First FFT Using cuFFTDx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction1.html#defining-basic-fft">Defining Basic FFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction1.html#executing-fft">Executing FFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction1.html#launching-fft-kernel">Launching FFT Kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction1.html#compilation">Compilation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../introduction2.html">Your Next Custom FFT Kernels</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction2.html#using-optimal-parameters">Using Optimal parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction2.html#extra-shared-memory">Extra Shared Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction2.html#what-happens-under-the-hood">What happens under the hood</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../introduction2.html#why">Why?</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Achieving High Performance</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#general-advice">General Advice</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#kernel-fusion">Kernel Fusion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#advanced">Advanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#further-reading">Further Reading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../performance.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">cuFFTDx API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="operators.html">Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="operators.html#description-operators">Description Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="operators.html#size-operator">Size Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="operators.html#direction-operator">Direction Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="operators.html#type-operator">Type Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="operators.html#precision-operator">Precision Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="operators.html#sm-operator">SM Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="operators.html#realfftoptions-operator">RealFFTOptions Operator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="operators.html#execution-operators">Execution Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="operators.html#thread-operator">Thread Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="operators.html#block-operator">Block Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="operators.html#block-configuration-operators">Block Configuration Operators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="traits.html">Traits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="traits.html#description-traits">Description Traits</a><ul>
<li class="toctree-l4"><a class="reference internal" href="traits.html#size-trait">Size Trait</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#type-trait">Type Trait</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#direction-trait">Direction Trait</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#precision-trait">Precision Trait</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#is-fft-trait">Is FFT? Trait</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#is-fft-execution-trait">Is FFT Execution? Trait</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#is-fft-complete-trait">Is FFT-complete? Trait</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#is-fft-complete-execution-trait">Is FFT-complete Execution? Trait</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="traits.html#execution-traits">Execution Traits</a><ul>
<li class="toctree-l4"><a class="reference internal" href="traits.html#thread-traits">Thread Traits</a></li>
<li class="toctree-l4"><a class="reference internal" href="traits.html#block-traits">Block Traits</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="traits.html#other-traits">Other Traits</a><ul>
<li class="toctree-l4"><a class="reference internal" href="traits.html#cufftdx-is-supported">cufftdx::is_supported</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Execution Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thread-execute-method">Thread Execute Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-execute-method">Block Execute Method</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#shared-memory-usage">Shared Memory Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#make-workspace-function">Make Workspace Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#value-formats-and-data-layouts">Value Formats and Data Layouts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#value-formats">Value Formats</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-layouts">Data Layouts</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#introduction-examples">Introduction Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#simple-fft-examples">Simple FFT Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples.html#simple-fft-thread-examples">simple_fft_thread* Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples.html#simple-fft-block-examples">simple_fft_block* Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples.html#extra-simple-fft-block-examples">Extra simple_fft_block(*) Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#nvrtc-examples">NVRTC Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#fft-performance">FFT Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#convolution-examples">Convolution Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#d-3d-fft-advanced-examples">2D/3D FFT Advanced Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#mixed-precision-fft-examples">Mixed Precision FFT Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html#input-output-helper-functions">Input/Output Helper Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../release_notes.html#id1">1.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../release_notes.html#id2">1.2.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#new-features">New Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#resolved-issues">Resolved Issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../release_notes.html#id3">1.1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#id4">New Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#id5">Resolved Issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../release_notes.html#id6">1.1.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#id7">New Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#known-issues">Known Issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../release_notes.html#id8">1.0.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#id9">New Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#id10">Resolved Issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../release_notes.html#id11">0.3.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../release_notes.html#id12">Known Issues</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">Software License Agreement</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">cuFFTDx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">cuFFTDx API Reference</a></li>
      <li class="breadcrumb-item active">Execution Methods</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="execution-methods">
<span id="execution-methods-label"></span><h1>Execution Methods<a class="headerlink" href="#execution-methods" title="Permalink to this heading">¶</a></h1>
<p>These methods are used to run the FFT operation.</p>
<p>A code example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cufftdx.hpp&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="n">FFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Size</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Type</span><span class="o">&lt;</span><span class="n">fft_type</span><span class="o">::</span><span class="n">c2c</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">                    </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Direction</span><span class="o">&lt;</span><span class="n">fft_direction</span><span class="o">::</span><span class="n">forward</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">                    </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Precision</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Block</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>

<span class="k">using</span><span class="w"> </span><span class="n">complex_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>

<span class="n">__global__</span><span class="w"> </span><span class="nf">kernel</span><span class="p">(...</span><span class="w"> </span><span class="cm">/* arguments */</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Shared memory pointer</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="n">__align__</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">))</span><span class="w"> </span><span class="n">complex_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span>

<span class="w">  </span><span class="c1">// Register data</span>
<span class="w">  </span><span class="n">complex_type</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">FFT</span><span class="o">::</span><span class="n">storage_size</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Load data into registers (thread_data)</span>
<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store results (thread_data) into global memory</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="thread-execute-method">
<span id="thread-execute-method-label"></span><h2>Thread Execute Method<a class="headerlink" href="#thread-execute-method" title="Permalink to this heading">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
</pre></div>
</div>
<p>Runs the FFT operation defined by the FFT descriptor. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">T</span></code> can be any type (such as <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">float2</span></code> or <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">double2</span></code>),
as long as its alignment and element size are the same as those of <a class="reference internal" href="traits.html#valuetype-thread-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<p>This method is available if the descriptor has been constructed using the <a class="reference internal" href="operators.html#thread-operator-label"><span class="std std-ref">Thread Operator</span></a> and
<a class="reference internal" href="traits.html#isfftcompleteexecution-trait-label"><span class="std std-ref">cufftdx::is_complete_fft_execution</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>.</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> array should be in registers. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> must fit <a class="reference internal" href="traits.html#storage-thread-trait-label"><span class="std std-ref">FFT::storage_size</span></a>
elements of type <a class="reference internal" href="traits.html#valuetype-thread-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is not guaranteed that executions of exactly the same FFTs on GPUs of different CUDA architectures will produce
bit-identical results.</p>
</div>
</div>
<div class="section" id="block-execute-method">
<span id="block-execute-method-label"></span><h2>Block Execute Method<a class="headerlink" href="#block-execute-method" title="Permalink to this heading">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// #1</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">workspace_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">workspace</span><span class="p">)</span>

<span class="c1">// #2: Version of #1 for FFTs which don&#39;t require workspace</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory</span><span class="p">)</span>

<span class="c1">// #3: Execute with input data in shared memory</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory_input</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">workspace_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">workspace</span><span class="p">)</span>

<span class="c1">// #4: Version of #3 for FFTs which don&#39;t require workspace</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory_input</span><span class="p">)</span>
</pre></div>
</div>
<p>Runs the FFT operation defined by the FFT descriptor. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">T</span></code> can be any type (such as <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">float2</span></code> or <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">double2</span></code>),
as long as its alignment and element size are the same as those of <a class="reference internal" href="traits.html#valuetype-block-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<p>This method is available if the descriptor has been constructed using the <a class="reference internal" href="operators.html#block-operator-label"><span class="std std-ref">Block Operator</span></a>
and <a class="reference internal" href="traits.html#isfftcompleteexecution-trait-label"><span class="std std-ref">cufftdx::is_complete_fft_execution</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>.</p>
<p>When <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">false</span></code>, overloads #2 and #4 can be used. Otherwise, user has to use
methods #1 or #3 and pass a reference to a workspace.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The library code assumes that both <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code> and <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> are aligned to 128 bits for optimal memory operations.
This can be accomplished by using either <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">__align__</span></code> or <code class="code highlight cpp docutils literal highlight-cpp"><span class="k">alignas</span></code> compiler directives. Proper alignment is demonstrated in example
<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">simple_fft_block_shared</span></code>. Please consult CUDA C++ Programming Guide for furher details on memory alignment. Although not required
the user may also consider aligning thread local arrays in the same way, to reduce kernel resource usage.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Examples of how to make sure shared memory pointer is aligned to 128 bits (16 bytes):</span>
<span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="n">float4</span><span class="p">)</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                               </span><span class="c1">// 1</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">__align__</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                                    </span><span class="c1">// 2</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">__align__</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">))</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                       </span><span class="c1">// 3</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                                                      </span><span class="c1">// 4</span>

<span class="c1">// Warning: std::aligned_storage became deprecated in C++23</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">aligned_storage_t</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">float4</span><span class="p">),</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">     </span><span class="c1">// 5</span>
</pre></div>
</div>
</div>
</div>
<p>In methods #1 and #2 <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> is in thread local arrays, and <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code> is a pointer to a shared memory of size
<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span></code> bytes. The operation is in-place meaning the results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> must
fit <a class="reference internal" href="traits.html#storage-block-trait-label"><span class="std std-ref">FFT::storage_size</span></a> elements of type <a class="reference internal" href="traits.html#valuetype-block-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Methods #1 and #2 don’t assume that shared memory (<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code>) is safe to modify or access without block synchronization,
and perform required synchronization (<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">__syncthreads</span><span class="p">()</span></code>) before the first use of it. Also, methods #1 and #2 don’t
synchronize any threads within a block after the last operation on shared memory is done. If that shared memory is going to be
reused later a synchronization has to be performed first.</p>
</div>
<p>In methods #3 and #4 the input data is passed in shared memory (<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>). The operation is in-place, meaning
the results are stored back to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>. These methods don’t require an additional <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code> pointer
to be passed, as <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> will be used for the required communication between threads. Thus, <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>
must fit all input and output values, and can’t be smaller than <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span></code> bytes
(i.e. shared memory size in bytes is a maximum of <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span></code>, <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&lt;</span><span class="n">FFT_input_size_in_bytes</span><span class="o">&gt;</span></code>, and
<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&lt;</span><span class="n">FFT_output_size_in_bytes</span><span class="o">&gt;</span><span class="p">)</span></code> bytes).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Methods #3 and #4, which get input via shared memory, assume that a synchronization was already performed and the data can be safely
accessed. Methods don’t synchronize any threads within a block after the last operation on shared memory is done.
Before reading from or writing to shared memory a synchronization has to be performed first.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is not guaranteed that executions of the same FFTs (size, direction, type, precision) but with different</p>
<ul class="simple">
<li><p>number of elements per thread (<a class="reference internal" href="operators.html#ept-operator-label"><span class="std std-ref">ElementsPerThread</span></a>),</p></li>
<li><p>number of FFTs calculated per CUDA block (<a class="reference internal" href="operators.html#fftsperblock-operator-label"><span class="std std-ref">FFTsPerBlock</span></a>), or</p></li>
<li><p>block dimension (<a class="reference internal" href="operators.html#blockdim-operator-label"><span class="std std-ref">BlockDim</span></a>),</p></li>
</ul>
<p>will produce bit-identical results.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is not guaranteed that executions of exactly the same FFTs on GPUs of different CUDA architectures will produce
bit-identical results.</p>
</div>
<div class="section" id="shared-memory-usage">
<span id="execution-methods-shared-memory-label"></span><h3>Shared Memory Usage<a class="headerlink" href="#shared-memory-usage" title="Permalink to this heading">¶</a></h3>
<p>It’s important to note that large FFTs may require more than 48 KB of shared memory per CUDA block. Therefore, as described
in <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA Programming Guide</a>
(<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications__technical-specifications-per-compute-capability">#1</a>,
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#shared-memory-7-x">#2</a>,
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#shared-memory-8-x">#3</a>), kernels with such FFTs must use
the dynamic shared memory rather than statically sized shared memory arrays. Additionally, these kernels require
an explicit opt-in using <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cudaFuncSetAttribute</span><span class="p">()</span></code> to set the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cudaFuncAttributeMaxDynamicSharedMemorySize</span></code>. See example code
below and the <a class="reference internal" href="../introduction2.html#intro2-extra-shared-memory-label"><span class="std std-ref">introduction example</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cufftdx.hpp&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">cufftdx</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">FFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">Size</span><span class="o">&lt;</span><span class="mi">16384</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Precision</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Type</span><span class="o">&lt;</span><span class="n">fft_type</span><span class="o">::</span><span class="n">c2c</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">                     </span><span class="o">+</span><span class="w"> </span><span class="n">Direction</span><span class="o">&lt;</span><span class="n">fft_direction</span><span class="o">::</span><span class="n">forward</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">SM</span><span class="o">&lt;</span><span class="mi">800</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Block</span><span class="p">());</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">block_fft_kernel</span><span class="p">(</span><span class="n">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// dynamic shared memory</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">__align__</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">))</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span>

<span class="w">  </span><span class="p">(...)</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">(...)</span>

<span class="w">  </span><span class="c1">// Increases the max dynamic shared memory size to match FFT requirements</span>
<span class="w">  </span><span class="n">cudaFuncSetAttribute</span><span class="p">(</span><span class="n">block_fft_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">cudaFuncAttributeMaxDynamicSharedMemorySize</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Invokes kernel with FFT::block_dim threads in CUDA block</span>
<span class="w">  </span><span class="n">block_fft_kernel</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">block_dim</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">workspace</span><span class="p">);</span>

<span class="w">  </span><span class="p">(...)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="make-workspace-function">
<span id="make-workspace-method-label"></span><h3>Make Workspace Function<a class="headerlink" href="#make-workspace-function" title="Permalink to this heading">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">FFT</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cudaError_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cudaError_t</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="p">)</span></code> is a helper function for creating workspace required for block <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">execute</span><span class="p">(...)</span></code> method
when <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span></code> is type of FFT descriptor. If no stream
argument is passed, the default 0 stream is used for execution. If after calling the function <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">error</span></code> is not <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cudaSuccess</span></code> the
workspace was not created correctly and is invalid.</p>
<ul class="simple">
<li><p>If <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> trait is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">false</span></code>, user doesn’t have to create workspace.</p></li>
<li><p>Workspace can be created for FFT with <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">requires_workspace</span></code> equal to false: such workspace is an empty workspace with no global memory allocation.</p></li>
<li><p>Workspace object is valid only for FFT it was created for.</p></li>
<li><p>Workspace object can allocate global memory, however never more than <a class="reference internal" href="traits.html#workspacesize-block-trait-label"><span class="std std-ref">FFT::workspace_size</span></a>,
and it’s responsible for freeing it.</p></li>
<li><p>Workspace can’t be used concurrently since all copies share the same underlying global memory allocation. Using workspace concurrently will result in memory races.</p></li>
<li><p>Allocated global memory is freed upon destruction of the last copy of created workspace object.</p></li>
<li><p>Workspace object can be implicitly cast to <a class="reference internal" href="traits.html#workspacetype-block-trait-label"><span class="std std-ref">FFT::workspace_type</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<blockquote>
<div><p>Workspace is not required for FFTs of following sizes:</p>
<ul class="simple">
<li><p>Powers of 2 up to 32768</p></li>
<li><p>Powers of 3 up to 19683</p></li>
<li><p>Powers of 5 up to 15625</p></li>
<li><p>Powers of 6 up to 1296</p></li>
<li><p>Powers of 7 up to 2401</p></li>
<li><p>Powers of 10 up to 10000</p></li>
<li><p>Powers of 11 up to 1331</p></li>
<li><p>Powers of 12 up to 1728</p></li>
</ul>
<dl class="simple">
<dt>In the future versions of cuFFTDx:</dt><dd><ul class="simple">
<li><p>Workspace requirement may be removed for other configurations.</p></li>
<li><p>FFT configurations that do not require workspace will continue to do so.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="traits.html#workspacetype-block-trait-label"><span class="std std-ref">FFT::workspace_type</span></a> object doesn’t track lifetime of underlying memory, and
is only valid within a lifetime of workspace object it was casted from.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Type returned by <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cudaError_t</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="p">)</span></code> can be different for different FFT descriptions,
and is not the same as <a class="reference internal" href="traits.html#workspacetype-block-trait-label"><span class="std std-ref">FFT::workspace_type</span></a>. User should use <code class="code highlight cpp docutils literal highlight-cpp"><span class="k">auto</span></code> when
creating a workspace object. Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">FFT</span><span class="o">&gt;</span>
<span class="n">__launch_bounds__</span><span class="p">(</span><span class="n">FFT</span><span class="o">::</span><span class="n">max_threads_per_block</span><span class="p">)</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">block_fft_kernel</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">workspace_type</span><span class="w"> </span><span class="n">workspace</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// Execute FFT</span>
<span class="w">    </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">,</span><span class="w"> </span><span class="n">workspace</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Create workspace</span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">workspace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// Run kernel with FFT</span>
<span class="n">block_fft_kernel</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">block_dim</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">workspace</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="value-formats-and-data-layouts">
<span id="execution-methods-formats-layouts-label"></span><h2>Value Formats and Data Layouts<a class="headerlink" href="#value-formats-and-data-layouts" title="Permalink to this heading">¶</a></h2>
<p>To perform the FFT correctly data needs to be passed to the library in a specific format described
in section <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a> and partitioned among threads as detailed in
section <a class="reference internal" href="#execution-methods-data-layout-label"><span class="std std-ref">Data Layouts</span></a>. The user is responsible for getting these
two factors right, but the library provides idioms, traits and examples which should make API use
accessible and intuitive.</p>
<div class="section" id="value-formats">
<span id="execution-methods-value-format-label"></span><h3>Value Formats<a class="headerlink" href="#value-formats" title="Permalink to this heading">¶</a></h3>
<p>For complex numbers of single and double precision, the first value in a complex number is the real part and the second is
the imaginary part.</p>
<p>The input value format for complex-to-complex and complex-to-real FFTs is the aforementioned complex type, but for real-to-complex FFT this property is dependent on the use
of <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a> and specifically its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span></code> enum value. By default the real-to-complex execution takes real values as arguments,
but if the execution mode is set to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> the library performs an optimized execution which treats real input as complex input of half the size.
In this case the value format is complex (identical to that of complex-to-complex or complex-to-real) containing two real values.</p>
<p>Similarly, the output value format for complex-to-complex and real-to-complex FFTs is the complex type, but for complex-to-real FFT this property is dependent on the use
of <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a> and specifically its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span></code> enum value. By default the complex-to-real execution outputs real values as results,
but if the execution mode is set to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> the library performs an optimized execution which treats real output as complex output of half the size.
In this case the value format is complex (identical to that of complex-to-complex or complex-to-real) and otherwise it’s made of real values.</p>
<div class="section" id="half-precision-implicit-batching">
<span id="execution-methods-half-implicit-batching-label"></span><h4>Half Precision Implicit Batching<a class="headerlink" href="#half-precision-implicit-batching" title="Permalink to this heading">¶</a></h4>
<p>Processing of half (fp16) precision FFTs in cuFFTDx is implicitly batched, that is, a single computation processes two FFT
batches. cuFFTDx expects that a complex number of half precision has 2 real parts and 2 imaginary parts in that order
(i.e real<sub>0</sub>, real<sub>1</sub>, imaginary<sub>0</sub>, imaginary<sub>1</sub>). Real values of half precision (for R2C and C2R FFTs)
follow the same logic and each should contain two real values. See also <a class="reference internal" href="traits.html#implicit-type-batching-block-trait-label"><span class="std std-ref">FFT::implicit_type_batching</span></a>
trait.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{complex half precision value:}\;\; &amp; (real_0, real_1, imaginary_0, imaginary_1) \\
\text{real half precision value:}\;\;    &amp; (real_0, real_1) \\\end{split}\]</div>
</div>
</div>
<div class="section" id="data-layouts">
<span id="execution-methods-data-layout-label"></span><h3>Data Layouts<a class="headerlink" href="#data-layouts" title="Permalink to this heading">¶</a></h3>
<p>Input and output data layouts of an FFT depend strictly on its configuration and the selected transform type. A data layout
describes the size and the pattern of input or output data for the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">execute</span></code> methods, no matter if input/output are partitioned
between threads into thread local arrays or stored contiguously in shared memory.</p>
<p>As the section <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a> put forth, the input / output formats are either real or complex. Another
important execution attribute is the sequence length.
In complex-to-complex transforms this property is equal to transform size, but for real-to-complex and complex-to-real
the library offers a few options to choose from.
This choice can be made by means of the <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a> operator.</p>
<p>The sections below provide detailed descriptions of the input and output data layouts for both
<a class="reference internal" href="#thread-execute-method-label"><span class="std std-ref">thread</span></a> and <a class="reference internal" href="#block-execute-method-label"><span class="std std-ref">block</span></a> execution modes .</p>
<div class="section" id="complex-to-complex">
<span id="c2c-data-layouts-label"></span><h4>Complex-to-complex<a class="headerlink" href="#complex-to-complex" title="Permalink to this heading">¶</a></h4>
<p>In the case of complex-to-complex transforms both the input and output data must be a complex array in a corresponding precision.
Both input and output arrays are always of the same length, equal to the size of the FFT.</p>
<div class="section" id="input-output-in-registers-for-thread-execution">
<h5>Input/Output in Registers for Thread Execution<a class="headerlink" href="#input-output-in-registers-for-thread-execution" title="Permalink to this heading">¶</a></h5>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> in the natural order.
Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.</p>
</div>
<div class="section" id="input-output-in-registers-for-block-execution">
<h5>Input/Output in Registers for Block Execution<a class="headerlink" href="#input-output-in-registers-for-block-execution" title="Permalink to this heading">¶</a></h5>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span></code>-th thread (indexing from 0) participating in the FFT should include the following elements of FFT in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>
values: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span></code> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">i</span></code> is an index in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>.
Results are later stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.
Please note that in certain cases, especially if <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>, the
values are not partitioned equally between threads.</p>
<p>See also <a class="reference internal" href="traits.html#stride-block-trait-label"><span class="std std-ref">FFT::stride</span></a>.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<p>0th thread of 8-point FFT with <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span></code> equal to 2 should have values 0, 2, 4, and 6 in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>.</p>
<p>Elements are not always perfectly divisible among threads:
0th thread of a 7-point FFT with <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span></code> equal to 2 should have values 0, 2, 4, and 6 in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>, while the 1st thread should have values 1, 3 and 5.</p>
</div>
</div>
<div class="section" id="input-output-in-shared-memory-for-block-execution">
<h5>Input/Output in Shared Memory for Block Execution<a class="headerlink" href="#input-output-in-shared-memory-for-block-execution" title="Permalink to this heading">¶</a></h5>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> in the natural order.
Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> following the same rule.</p>
</div>
</div>
<div class="section" id="real-to-complex-and-complex-to-real">
<h4>Real-to-complex and complex-to-real<a class="headerlink" href="#real-to-complex-and-complex-to-real" title="Permalink to this heading">¶</a></h4>
<p>For real-to-complex (R2C) and complex-to-real (C2R) FFT input and output data layouts depend on the <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a>.
By default <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">RealFFTOptions</span></code> is set to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> and <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code>.</p>
<ul class="simple">
<li><p>Complex layouts: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> (default), <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code>, <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code>.</p></li>
<li><p>Real modes: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> (default), <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code>.</p></li>
</ul>
<div class="section" id="complex-element-layouts">
<span id="complex-data-layouts-label"></span><h5>Complex Element Layouts<a class="headerlink" href="#complex-element-layouts" title="Permalink to this heading">¶</a></h5>
<p>Complex element layout is defined for the complex-to-real input and real-to-complex output.
It depends on the passed <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span></code> value of the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">RealFFTOptions</span></code> operator.</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> for even length ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), … , (r <sub>N/2</sub>, i <sub>N/2</sub> = 0)), only non-redundant <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span></code> elements, with first and last elements containing only real parts.</p>
<ul>
<li><p>imag<sub>0</sub> and imag<sub>N/2</sub> are both assumed to 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> for odd length ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), … , (r <sub>⌊N/2⌋</sub>, i <sub>⌊N/2⌋</sub>)), only non-redundant <code class="code highlight cpp docutils literal highlight-cpp">⌊N/2⌋ + 1</code> elements, with first element containing only the real part.</p>
<ul>
<li><p>imag<sub>0</sub> is assumed to be 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code> ((r<sub>0</sub>, i<sub>0</sub>), (r<sub>1</sub>, i<sub>1</sub>), … , (r <sub>N/2 - 1</sub>, i <sub>N/2 - 1</sub>)), packs the last real element into the imaginary component of the first element.</p>
<ul>
<li><p>Packing means that the first element x<sub>0</sub> contains (real<sub>0</sub>, real<sub>⌊N/2⌋</sub>).</p></li>
<li><p>Allowed only for even sizes, e.g. for 16-point FFT the length is 8, for 15-point it is unavailable.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code> for even lengths ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), … , (r<sub>N/2</sub>, i<sub>N/2</sub> = 0), … , (r<sub>N - 1</sub>, i<sub>N - 1</sub>)), all elements, including redundant ones, since the output is hermitian.</p>
<ul>
<li><p>For example, for 16-point FFT the length is 16</p></li>
<li><p>imag<sub>0</sub> and imag<sub>N/2</sub> are both assumed to be 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code> for odd lengths ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub> ), … , (r<sub>N - 1</sub>, i<sub>N - 1</sub>)), all elements, including redundant ones, since the output is hermitian.</p>
<ul>
<li><p>For example, for 15-point FFT the length is 15</p></li>
<li><p>imag<sub>0</sub> is assumed to be 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
</ul>
<div class="section" id="complex-input-output-in-registers-for-thread-execution">
<h6>Complex Input/Output in Registers for Thread Execution<a class="headerlink" href="#complex-input-output-in-registers-for-thread-execution" title="Permalink to this heading">¶</a></h6>
<p>Follows the same rules as described in <a class="reference internal" href="#complex-data-layouts-block-smem-label"><span class="std std-ref">Complex Input/Output In Shared Memory for Block Execution</span></a>, but
the input/output data is stored in a thread local array.</p>
</div>
<div class="section" id="complex-input-output-in-registers-for-block-execution">
<h6>Complex Input/Output in Registers for Block Execution<a class="headerlink" href="#complex-input-output-in-registers-for-block-execution" title="Permalink to this heading">¶</a></h6>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span></code>-th thread (indexing from 0) participating in the FFT should include the following elements of FFT in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>
values: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span></code> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">i</span></code> is an index in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>. Results are later stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.
Please note that in certain cases, especially if <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>, the
values are not partitioned equally between threads.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 16-point FP32/FP64 C2R FFT with <a class="reference internal" href="operators.html#ept-operator-label"><span class="std std-ref">ElementsPerThread</span></a> set or defaulted to 4
(implying 4 threads, and <a class="reference internal" href="traits.html#stride-block-trait-label"><span class="std std-ref">FFT::stride</span></a> equal to 4):</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code>: the input layout (first row) and required partitioning of the data (entire table) into thread local arrays is presented below:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, i<sub>0</sub> = 0)</p></th>
<th class="head"><p>(r<sub>1</sub>, i<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, i<sub>2</sub>)</p></th>
<th class="head"><p>(r<sub>3</sub>, i<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, i<sub>4</sub>)</p></th>
<th class="head"><p>(r<sub>5</sub>, i<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, i<sub>6</sub>)</p></th>
<th class="head"><p>(r<sub>7</sub>, i<sub>7</sub>),</p></th>
<th class="head"><p>(r<sub>8</sub>, i<sub>8</sub> = 0)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code>: the input layout (first row) and required partitioning of the data (entire table) into a thread array is presented below:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 15%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, r<sub>8</sub>)</p></th>
<th class="head"><p>(r<sub>1</sub>, i<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, i<sub>2</sub>)</p></th>
<th class="head"><p>(r<sub>3</sub>, i<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, i<sub>4</sub>)</p></th>
<th class="head"><p>(r<sub>5</sub>, i<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, i<sub>6</sub>)</p></th>
<th class="head"><p>(r<sub>7</sub>, i<sub>7</sub>),</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code>: the input layout (first row) and required partitioning of the data (entire table) into thread local arrays is presented below:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 4%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, i<sub>0</sub> = 0)</p></th>
<th class="head"><p>(r<sub>1</sub>, i<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, i<sub>2</sub>)</p></th>
<th class="head"><p>(r<sub>3</sub>, i<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, i<sub>4</sub>)</p></th>
<th class="head"><p>(r<sub>5</sub>, i<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, i<sub>6</sub>)</p></th>
<th class="head"><p>(r<sub>7</sub>, i<sub>7</sub>),</p></th>
<th class="head"><p>(r<sub>8</sub>, i<sub>8</sub> = 0)</p></th>
<th class="head"><p>(r<sub>9</sub>, i<sub>9</sub>)</p></th>
<th class="head"><p>(r<sub>10</sub>, i<sub>10</sub>)</p></th>
<th class="head"><p>(r<sub>11</sub>, i<sub>11</sub>)</p></th>
<th class="head"><p>(r<sub>12</sub>, i<sub>12</sub>)</p></th>
<th class="head"><p>(r<sub>13</sub>, i<sub>13</sub>)</p></th>
<th class="head"><p>(r<sub>14</sub>, i<sub>14</sub>)</p></th>
<th class="head"><p>(r<sub>15</sub>, i<sub>15</sub>),</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The layouts and the required partitioning look similarly for R2C output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="complex-input-output-in-shared-memory-for-block-execution">
<span id="complex-data-layouts-block-smem-label"></span><h6>Complex Input/Output in Shared Memory for Block Execution<a class="headerlink" href="#complex-input-output-in-shared-memory-for-block-execution" title="Permalink to this heading">¶</a></h6>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> in the natural order.
Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> following the same rule.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 8-point FP32/FP64 C2R FFT:</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, imag<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), (r<sub>2</sub>, i<sub>2</sub>), (r<sub>3</sub>, i<sub>3</sub>),(r<sub>4</sub>, i<sub>4</sub> = 0)].</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, real<sub>4</sub>), (r<sub>1</sub>, i<sub>1</sub>), (r<sub>2</sub>, i<sub>2</sub>), (r<sub>3</sub>, i<sub>3</sub>)].</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, imag<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), (r<sub>2</sub>, i<sub>2</sub>), (r<sub>3</sub>, i<sub>3</sub>),(r<sub>4</sub>, i<sub>4</sub> = 0), (r<sub>5</sub>, i<sub>5</sub>), (r<sub>6</sub>, i<sub>6</sub>), (r<sub>7</sub>, i<sub>7</sub>)].</p></li>
</ul>
<p>The layouts look similarly for R2C output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="real-element-layouts">
<span id="real-data-layouts-label"></span><h5>Real Element Layouts<a class="headerlink" href="#real-element-layouts" title="Permalink to this heading">¶</a></h5>
<p>Real element layout is defined for the complex-to-real output and real-to-complex input.
It depends on <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span></code> parameter of the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">RealFFTOptions</span></code> operator:</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> (x<sub>0</sub>, x<sub>1</sub>, … , x<sub>N - 1</sub>), real element array of length equal to the transformation size.</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> (x<sub>0</sub>, x<sub>1</sub>, … , x <sub>N/2 - 1</sub>), complex element array of length half that of the transformation size.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The physical layout of the elements in shared memory is the same as in the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> case, but the logical one changes: instead of being an array of real values, it is an array of complex values.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> execution is dependent on certain FFT characteristics, and currently it is available in block execution only
for sizes equal to 2<sup>N</sup> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">N</span></code> is any exponent which still makes the transform fit into available size range. For thread
execution this optimization supports all sizes equal to 2 * N, where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">N</span></code> is any multiplier which makes the transform fit into available
size range. Using <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">folded</span></code> execution doubles the size limit available otherwise. Consult <a class="reference internal" href="../requirements_func.html#functionality-label"><span class="std std-ref">Supported Functionality</span></a> for further details.</p>
</div>
<div class="section" id="real-input-output-in-registers-for-thread-execution">
<h6>Real Input/Output in Registers for Thread Execution<a class="headerlink" href="#real-input-output-in-registers-for-thread-execution" title="Permalink to this heading">¶</a></h6>
<p>Follows the same rules as described in <a class="reference internal" href="#real-data-layouts-block-smem-label"><span class="std std-ref">Reak Input/Output In Shared Memory for Block Execution</span></a>, but
the input/output data is stored in a thread local array.</p>
</div>
<div class="section" id="real-input-output-in-registers-for-block-execution">
<h6>Real Input/Output in Registers for Block Execution<a class="headerlink" href="#real-input-output-in-registers-for-block-execution" title="Permalink to this heading">¶</a></h6>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span></code>-th thread (indexing from 0) participating in the FFT should include the following values of type <a class="reference internal" href="traits.html#input-type-block-trait-label"><span class="std std-ref">Input Type Trait</span></a>
: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span></code> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">i</span></code> is an index in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>.
Results are later stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.
Please note that in certain cases, especially if <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>, the
values are not partitioned equally between threads.
It is also important to remember that the count of values of this type per thread will be <a class="reference internal" href="traits.html#input-ept-block-trait-label"><span class="std std-ref">Input EPT Trait</span></a> and not <a class="reference internal" href="traits.html#ept-block-trait-label"><span class="std std-ref">Elements Per Thread Trait</span></a></p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 16-point FP32/FP64 R2C FFT with <a class="reference internal" href="operators.html#ept-operator-label"><span class="std std-ref">ElementsPerThread</span></a> set or defaulted to 4:</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> input layout looks like this: [real<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub>, r<sub>3</sub>, r<sub>4</sub>, r<sub>5</sub>, r<sub>6</sub>, r<sub>7</sub>].
The required partitioning of the data into thread local arrays is presented below:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>r<sub>0</sub></p></th>
<th class="head"><p>r<sub>1</sub></p></th>
<th class="head"><p>r<sub>2</sub></p></th>
<th class="head"><p>r<sub>3</sub></p></th>
<th class="head"><p>r<sub>4</sub></p></th>
<th class="head"><p>r<sub>5</sub></p></th>
<th class="head"><p>r<sub>6</sub></p></th>
<th class="head"><p>r<sub>7</sub></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> input layout looks like this: [(real<sub>0</sub>, r<sub>1</sub>), (r<sub>2</sub>, r<sub>3</sub>), (r<sub>4</sub>, r<sub>5</sub>), (r<sub>6</sub>, r<sub>7</sub>)].
The required partitioning of the data into thread local arrays is presented below:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 25%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, r<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, r<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, r<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, r<sub>7</sub>)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The layouts and the required partitioning look similarly for C2R output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="real-input-output-in-shared-memory-for-block-execution">
<span id="real-data-layouts-block-smem-label"></span><h6>Real Input/Output in Shared Memory for Block Execution<a class="headerlink" href="#real-input-output-in-shared-memory-for-block-execution" title="Permalink to this heading">¶</a></h6>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> in natural order. Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>
following the same rule.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 8-point FP32/FP64 R2C FFT:</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [real<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub>, r<sub>3</sub>, r<sub>4</sub>, r<sub>5</sub>, r<sub>6</sub>, r<sub>7</sub>]</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, r<sub>1</sub>), (r<sub>2</sub>, r<sub>3</sub>), (r<sub>4</sub>, r<sub>5</sub>), (r<sub>6</sub>, r<sub>7</sub>)]</p></li>
</ul>
<p>The layouts look similarly for C2R output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</div>
</div>
</div>
<div class="section" id="loading-and-storing-data">
<h4>Loading and Storing Data<a class="headerlink" href="#loading-and-storing-data" title="Permalink to this heading">¶</a></h4>
<p>To deal with the complexity of changing input and output lengths depending on configuration, the library provides
various traits allowing for easy memory operations. <a class="reference internal" href="traits.html#input-length-block-trait-label"><span class="std std-ref">Input Length Trait</span></a> and
<a class="reference internal" href="traits.html#output-length-block-trait-label"><span class="std std-ref">Output Length Trait</span></a> describe lengths of respectively input and output arrays.
This covers real-to-complex (R2C) and complex-to-real (C2R) cases described above.
<a class="reference internal" href="traits.html#input-ept-block-trait-label"><span class="std std-ref">Input EPT Trait</span></a> describes the count of elements to be loaded by each thread,
assuming that each element is of type <a class="reference internal" href="traits.html#input-type-block-trait-label"><span class="std std-ref">Input Type Trait</span></a>.
Respectively <a class="reference internal" href="traits.html#output-ept-block-trait-label"><span class="std std-ref">Output EPT Trait</span></a> and <a class="reference internal" href="traits.html#output-type-block-trait-label"><span class="std std-ref">Output Type Trait</span></a> describe the same properties for storing output.</p>
<p>The detailed idiomatic IO is shown in <a class="reference internal" href="../examples.html#examples-label"><span class="std std-ref">examples</span></a>, but the general approach for loading data from global memory is as follows:</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<p><strong>Block FFT with Data in Registers</strong></p>
<p>The following example shows block trait-based universal loading scheme for cuFFTDx register API execution mode. Here
a thread group performs an FFT cooperatively, so the data needs to be spread among all participants. The following
code snippets already account for this partitioning, but also different value formats (as described in
<a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a>) and data layouts (as described in <a class="reference internal" href="#real-data-layouts-label"><span class="std std-ref">Real Element Layouts</span></a>
and <a class="reference internal" href="#complex-data-layouts-label"><span class="std std-ref">Complex Element Layouts</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Which FFT in this block is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">local_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="c1">// Which FFT in this grid is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">local_fft_id</span><span class="p">;</span>
<span class="c1">// Memory offset for accessing the first element of the global_fft</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>

<span class="c1">// Cast registers to type required as input to FFT execution</span>
<span class="k">using</span><span class="w"> </span><span class="n">input_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">input_type</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">thread_fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">thread_data</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

<span class="k">auto</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_ept</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">thread_fft_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fft_data</span><span class="p">[</span><span class="n">global_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index</span><span class="p">];</span>
<span class="w">      </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p><strong>Block FFT with Data in Shared Memory</strong></p>
<p>The following example shows block trait-based universal loading scheme for cuFFTDx shared memory API execution mode. Here
entire CUDA block performs <span class="xref std std-ref">ffts-per-block-trait</span> FFTs cooperatively, so the data in shared memory needs to contain
all necessary batches. To access memory in coalesced manner the loading of all batches is performed by the entire threadblock.
The following code snippet accounts for different value formats (as described in <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a>)
and data layouts (as described in <a class="reference internal" href="#real-data-layouts-label"><span class="std std-ref">Real Element Layouts</span></a> and <a class="reference internal" href="#complex-data-layouts-label"><span class="std std-ref">Complex Element Layouts</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The index of first FFT being performed by threads of this block</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">block_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="p">;</span>
<span class="c1">// Offset in memory to the first element accessed by threads in this block</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_fft_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>
<span class="c1">// Combined length of all FFTs performed by threads of this block</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">block_input_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>

<span class="c1">// Cast registers to type required as input to FFT execution</span>
<span class="k">using</span><span class="w"> </span><span class="n">input_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">input_type</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">shared_fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">shared_memory</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

<span class="c1">// The entire block loads all required batches in a coalesced manner,</span>
<span class="c1">// threads will load elements from different batches than they will later</span>
<span class="c1">// execute on, and this is on purpose.</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">index</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_ept</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">block_input_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">shared_fft_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fft_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">stride</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following example shows thread trait-based universal loading scheme for cuFFTDx execution. Here a single thread
performs entire FFT, so there is no need to partition data, it will perform a load of entire sequence. This already
accounts for different value_formats (as described in <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a>) and data layouts
(as described in <a class="reference internal" href="#real-data-layouts-label"><span class="std std-ref">Real Element Layouts</span></a> and <a class="reference internal" href="#complex-data-layouts-label"><span class="std std-ref">Complex Element Layouts</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This example assumes a 2-dimensional block and 1-dimensional grid</span>

<span class="c1">// Which FFT in block is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">local_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="c1">// Which FFT in grid is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">local_fft_id</span><span class="p">;</span>
<span class="c1">// Memory offset for accessing first element of this FFT</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>

<span class="c1">// Cast registers to type required as input to FFT execution</span>
<span class="k">using</span><span class="w"> </span><span class="n">input_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">input_type</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">thread_fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">thread_data</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">thread_fft_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fft_data</span><span class="p">[</span><span class="n">global_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="traits.html" class="btn btn-neutral float-left" title="Traits" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">

<p style="color: gray;">
<a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank" style="color: inherit;">Privacy Policy</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank" style="color: inherit;">Manage My Privacy</a>
|
<a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank" style="color: inherit;">Do Not Sell or Share My Data</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank" style="color: inherit;">Terms of Service</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank" style="color: inherit;">Accessibility</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank" style="color: inherit;">Corporate Policies</a>
|
<a href="https://www.nvidia.com/en-us/product-security/" target="_blank" style="color: inherit;">Product Security</a>
|
<a href="https://www.nvidia.com/en-us/contact/" target="_blank" style="color: inherit;">Contact</a>
</p>

<p>
  Copyright &#169; 2022-2024, NVIDIA Corporation &amp; Affiliates. All rights reserved.
</p>

    <p></p>

  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
  a:link, a:visited {
    color: #76b900;
  }

  a:hover {
    color: #8c0;
  }

  .rst-content dl:not(.docutils) dt {
    background: rgba(118, 185, 0, 0.1);
    color: rgba(59,93,0,1);
    border-top: solid 3px rgba(59,93,0,1);
  }
  </style>
  

</body>
</html>